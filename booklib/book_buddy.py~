import requests
from bs4 import BeautifulSoup
import wget
from enum import Enum
import urllib.request
from urllib.error import HTTPError


my_book_list = [
    ('automate the boring stuff with python', 'pdf'),
#    ('Beyond the Basic Stuff with Python', 'pdf'),
#    ('Cracking Codes with Python', 'pdf'),    
]

VERBOSE = False
SOURCE = "http://libgen.rs"
LIBRARY_IN = '/home/emil/Books/unsorted/{title}.{_format}'
SEARCH_QUERY = 'http://libgen.rs/search.php?req={query}&open=0&res=25&view=simple&phrase=1&column=def'
DIVIDER="\n=========================================\n"


def auto_download():
    for book, _format in my_book_list:
        search_query = book
        results = search(search_query)
        book_selection = [parse_result(r) for r in results]
        my_bookstore = BookStore(book_selection).sort(_format=_format)
        try:
            selected_book = my_bookstore.pop()
            selected_book.download()
        except HTTPError as e:
            print(e)


def download_book(search_term, _format):
    try:
        results = search(search_term)
        book_selection = [parse_result(r) for r in results]
        my_bookstore = BookStore(book_selection).sort(_format=_format)
    except Exception as e:
        print(e)
        exit(1)
    try:
        selected_book = my_bookstore.pop()
        print('Attempting to download the following book:\n')
        print(selected_book)
        selected_book.download()
    except HTTPError as e:
        print(e)
  
 
class BookProps:
    ID = 0
    AUTHOR = 1
    TITLE = 2
    PUBLISHER = 3
    YEAR = 4
    PAGES = 5
    LANGUAGE = 6
    SIZE = 7
    _FORMAT = 8

class Book( object ):
    def __init__(self, book_metadata):
        _notify('BOOK metadata')
        _notify(book_metadata)
        self._id = book_metadata[BookProps.ID].text
        self.author = book_metadata[BookProps.AUTHOR].a.text
        self.title = book_metadata[BookProps.TITLE].a.text
        self.publisher = book_metadata[BookProps.PUBLISHER].text
        self.year = book_metadata[BookProps.YEAR].text
        self.pages = book_metadata[BookProps.PAGES].text
        self.language = book_metadata[BookProps.LANGUAGE].text
        self.size = book_metadata[BookProps.SIZE].text
        self._format = book_metadata[BookProps._FORMAT].text
        self.download_page = book_metadata[BookProps.TITLE].a.get('href')
        
    def __str__(self):
        return f"[{self._id}] {self.title}\n by {self.author}\nFormat: {self._format}, size: {self.size}"

    def get_download_link(self):
        dl_page_soup = fetch_soup(SOURCE + '/' + self.download_page)
        next_dl_page = dl_page_soup.find('a', title='Gen.lib.rus.ec').get('href')
        _notify('next page')
        _notify(next_dl_page)
        if not next_dl_page:
            raise Exception('could not follow 1st download link')
        next_dl_soup = fetch_soup(next_dl_page)
        download_link = next_dl_soup.find('div', id='download')
        _notify(f'unproc dl link {download_link}')
        download_link = download_link.h2
        _notify(f'unproc 2 dl link {download_link}')
        download_link = download_link.a
        _notify(f'unproc 3 dl link {download_link}')
        download_link = download_link['href']
        _notify(download_link)
        return download_link

    def download(self):
        dl_link = self.get_download_link()
        wget.download(dl_link, f'/home/emil/Books/unsorted/{self.title}.{self._format}')
        
        
class BookStore():
    def __init__(self, book_list):
        self.book_list = book_list

    def sort(self, _format='pdf'):
        return BookStore([book for book in self.book_list if book._format == _format])

    def first(self):
        return self.book_list[0]

    def __str__(self):
        if not self.book_list:
            return 'The shelves are empty'
        book_store_str = self.book_list.__str__()
        for book in self.book_list[1:]:
            book_store_str += DIVIDER + book.__str__() + DIVIDER
        return book_store_str

    def pop(self):
        if not self.book_list:
            raise Exception('no books!')
        return self.book_list.pop()

    def has_books(self):
        if self.book_list:
            return True
        else:
            return False

      
def main():
    download_book(input('Enter a search term: ').lower(), input('Enter a format: ').lower())

def parse_result(book_soup):
    book_metadata = book_soup.find_all('td')
    _notify(book_metadata)
    book_metadata = book_metadata[:9]
    _notify(book_metadata)
    selected_book = Book(book_metadata)
    _notify(selected_book)
    return selected_book


def search(search_query):
    search_query = search_query.replace(' ', '+')
    results = scrape_results(fetch_soup(SEARCH_QUERY.format(query=search_query)))
    return results
    
def get_user_confirmation(book):
    print(book.title)
    print(f'Format: {book._format}')
    return input('Download this book? [y/n]') == 'y'
    
def fetch_soup(endpoint):
    _notify(f'Fetching soup page {endpoint}')
    source = requests.get(endpoint).text
    return BeautifulSoup(source, 'lxml')

# Download candidates is a list of links for a given book + format
def download(candidate_book):
    download_page_soup = fetch_soup(endpoint=candidate_book.link)
    download_link = download_page_soup.find('a', class_='btn btn-primary dlButton addDownloadedBook').get('href')
    _notify(f'Download link is\n {download_link}')
    urllib.request.urlretrieve('http://libgen.rs/book/index.php?md5=4A8E6B487A7C1DACA6563F7B3D70783B', LIBRARY_IN.format(
        title=candidate_book.title,
        _format='pdf'
    ))
    
def _notify(message):
    if VERBOSE:
        print(message)

def scrape_results(soup):
    _notify('Extracting results')
    results = soup.find('table', class_='c')
#    results = soup.find_all('div', class_='resItemBox resItemBoxBooks exactMatch')
    results = results.find_all('tr')[1:]
    num_results = len(results)
    _notify(f'Found {num_results} exact matches')
    if not num_results:
        raise Exception('No results found')
#    _notify(results)
    return results


main()

